#+STARTUP: showall
#+OPTIONS: num:1
#+TITLE: tmon: A temperature monitoring system

* Overview

A small, home-use *Raspberry Pi + ESP32* setup for monitoring
temperatures over *RS-485* or *WiFi*.

- *Server (Raspberry Pi):* Python daemon that collects readings from ESP32 clients and stores them in an SQLite database.
- *Transport:* RS-485 (USB adapter, server polls) or UDP over WiFi (clients push).
- *Clients (ESP32):* Each reads up to *4 NTC thermistors*.  Only the
  S3-DevKitC-1 version has been tested; pre-built firmware targets
  this model.
- *Protocol:* Simple custom binary frames with *CRC-16/MODBUS*.

Three services run on the Pi: a serial daemon that polls RS-485 clients, a UDP daemon that receives pushes from WiFi clients, and a web dashboard.  You can mix and match transport modes, but each client must have a unique address (see [[#flashing-client-firmware][Flashing client firmware]]).  Readings are stored in an SQLite database (see [[file:docs/storage.org][Storage Specification]]) and viewable from the web dashboard.

* Architecture

#+begin_example
                Raspberry Pi
  .-------------------------------------------.
  |  RS-485 server     (tmond-serial)         |
  |  WiFi server       (tmond-udp)            |
  |  web panel         (tmon-panel)           |
  |  database           (tmon.db)             |
  '-+---------------------------------------+-'
    |                                       |
    |  RS-485 bus                    WiFi (UDP)
    |                                       |
    +--+-------+-------+          +---------+---------+
       |       |       |          |                   |
     +---+   +---+   +---+      +---+               +---+
     | 1 |   | 4 |   | 5 |      | 2 |               | 3 |
     +---+   +---+   +---+      +---+               +---+

  [N] = ESP32 client at address N (up to 4 NTC thermistors each)
#+end_example

See the [[file:docs/wiring.org][Wiring Reference]] for how to connect the ESP32 clients, thermistors, and RS-485 bus.

* Installation

Installation is meant to be done on the Raspberry Pi, since that is
where you will likely deploy.  You can do so with:

#+begin_example
# On the Pi:
git clone https://github.com/aldyh/tmon.git
cd tmon
make
sudo make install
#+end_example

The installer copies default config files to ~/etc/tmon/~, pre-built firmware binaries to ~/var/lib/tmon/firmware/~, and supporting files to ~/var/lib/tmon/~.  The servers are meant to be run from systemd and are installed but *not* enabled -- see [[#running][Running]].

* Uninstalling

To uninstall:

#+begin_example
# Keep /etc/tmon, /var/lib/tmon and other configury
sudo make uninstall

# Remove everything including config and data
sudo make purge
#+end_example

* Configuration

Edit ~/etc/tmon/tmon.toml~ to match your setup:

#+begin_example
db = "tmon.db"

[rs485]
clients = [1, 4, 5]       # addresses to poll -- must match what you flashed
interval = 5              # seconds between poll cycles
port = "/dev/ttyUSB0"     # USB-RS485 adapter (try: ls /dev/ttyUSB*)
baudrate = 9600

[udp]
port = 5555               # UDP listen port
push_interval = 5         # how often clients push readings (seconds)
#+end_example

For WiFi/UDP clients, you also need ~/etc/tmon/wifi.toml~ with your network credentials:

#+begin_example
cp /etc/tmon/wifi.toml.example /etc/tmon/wifi.toml
#+end_example

#+begin_example
ssid = "your_wifi_ssid"
password = "your_wifi_password"
server_host = "192.168.1.100"    # IP of your Raspberry Pi
#+end_example

* Running
:PROPERTIES:
:CUSTOM_ID: running
:END:

Enable the two daemons (one for UDP and one for serial):

#+begin_example
sudo systemctl enable --now tmond-serial   # RS-485 server
sudo systemctl enable --now tmond-udp      # UDP push server
#+end_example

Enable the web dashboard:

#+begin_example
sudo systemctl enable --now tmon-panel     # accessible at http://IP_OF_RASPBERRY_PI:5000
#+end_example

Check status and logs:

#+begin_example
journalctl -u tmond-serial -f    # View RS-485 temp readings as they arrive.
journalctl -u tmond-udp -f       # View UDP temp readings as they arrive.
#+end_example

* Flashing client firmware
:PROPERTIES:
:CUSTOM_ID: flashing-client-firmware
:END:

Connect an ESP32 to the Pi via USB, then use ~tmon-flash~ to flash it.  Each client must have a unique address:

#+begin_example
tmon-flash --mode=serial --addr=1          # RS-485 client at address 1
tmon-flash --mode=udp    --addr=5          #    UDP client at address 5
#+end_example

The tool auto-detects the serial port, but you can use ~--port=/dev/ttyACM0~ to
override.

The built-in LED on each ESP32 signals operational status:

| Color           | Meaning                           |
|-----------------+-----------------------------------|
| Off             | Normal operation                  |
| Blinking red    | WiFi disconnected (UDP only)      |
| Blinking green  | Sending readings to server        |
| Blinking yellow | Identify: blinks N times (N=addr) |

Pressing the boot button triggers the identify sequence: the LED
blinks yellow N times, where N is the client address.  This lets you
verify which address a device has after flashing.

* Development

For contributors or anyone making local modifications.

** Build and test

These targets use local venvs and do not require a system-wide install.

#+begin_example
make                  # create venvs + dependencies
make check            # run full testsuite (no hardware needed)
#+end_example

** Run locally

To run the servers on the development environment without installing first:

#+begin_example
make run-server-485   # RS-485 (uses server/tmon.toml --transport rs485)
make run-server-udp   # UDP push (uses server/tmon.toml --transport udp)
make run-panel        # panel with mock data at http://localhost:5000
#+end_example

** Building firmware from source

The pre-built firmware is included in the repository, but if you need to rebuild it (requires [[https://platformio.org/][PlatformIO]] on an x86 machine):

#+begin_example
# On the development machine:
make firmware         # build ESP32 binaries into firmware/
scp -r firmware/ pi:~/tmon/
#+end_example

Then re-run ~sudo make install~ on the Pi to update the installed firmware.

* Documentation

- [[file:docs/protocol.org][Protocol Specification]]
- [[file:docs/wiring.org][Wiring Reference]]
- [[file:docs/storage.org][Storage Specification]]
