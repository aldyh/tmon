#+STARTUP: showall
#+OPTIONS: num:1
#+TITLE: tmon: A temperature monitoring system

* Overview

A small, home-use *Raspberry Pi + ESP32* setup for monitoring
temperatures over *RS-485* or *WiFi*.

- *Server (Raspberry Pi):* Python daemon that collects readings from ESP32 clients and stores them in an SQLite database.
- *Transport:* RS-485 (USB adapter, server polls) or WiFi (clients push over UDP).
- *Clients (ESP32):* Each reads up to *4 NTC thermistors*.  Only the
  S3-DevKitC-1 version has been tested; pre-built firmware targets
  this model.
- *Protocol:* Simple custom binary frames with *CRC-16/MODBUS*.

Three services run on the Pi: an RS-485 daemon that polls RS-485 clients, a WiFi daemon that receives pushes from WiFi clients, and a web dashboard.  You can mix and match transport modes, but each client must have a unique address (see [[#flashing-client-firmware][Flashing client firmware]]).  Readings are stored in an SQLite database (see [[file:docs/storage.org][Storage Specification]]) and viewable from the web dashboard.

* Architecture

#+begin_example
                Raspberry Pi
  .-------------------------------------------.
  |  RS-485 server     (tmond-485)            |
  |  WiFi server       (tmond-wifi)           |
  |  web panel         (tmon-panel)           |
  |  database           (tmon.db)             |
  '-+---------------------------------------+-'
    |                                       |
    |  RS-485 bus                    WiFi (UDP)
    |                                       |
    +--+-------+-------+          +---------+---------+
       |       |       |          |                   |
     +---+   +---+   +---+      +---+               +---+
     | 1 |   | 4 |   | 5 |      | 2 |               | 3 |
     +---+   +---+   +---+      +---+               +---+

  [N] = ESP32 client at address N (up to 4 NTC thermistors each)
#+end_example

See the [[file:docs/wiring.org][Wiring Reference]] for how to connect the ESP32 clients, thermistors, and RS-485 bus.

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

Installation is meant to be done on the Raspberry Pi.  The installer
walks you through configuration and starts the services:

#+begin_example
# On the Pi:
git clone https://github.com/aldyh/tmon.git
cd tmon
make
sudo make install
#+end_example

The installer asks whether to enable RS-485 and/or WiFi clients, then
prompts for the relevant settings (serial port, addresses, intervals).
It writes the config files, installs everything, and starts the
services -- no manual editing needed.

Re-running ~sudo make install~ overwrites the previous config.

** Uninstalling

#+begin_example
sudo make uninstall
#+end_example

** Manual configuration

For power users who want to edit config directly:

- ~/etc/tmon/tmon.toml~ -- RS-485 port, client addresses, poll interval, WiFi listen port
- ~/etc/tmon/wifi.toml~ -- WiFi credentials (SSID, password, server IP)

After editing, restart the relevant service:

#+begin_example
sudo systemctl restart tmond-485          # after changing [rs485] settings
sudo systemctl restart tmond-wifi         # after changing [wifi] or wifi.toml
#+end_example

** Logs

#+begin_example
journalctl -u tmond-485 -f       # View RS-485 temp readings as they arrive.
journalctl -u tmond-wifi -f      # View WiFi temp readings as they arrive.
#+end_example

* Flashing client firmware
:PROPERTIES:
:CUSTOM_ID: flashing-client-firmware
:END:

Connect an ESP32 to the Pi via USB, then use ~tmon-flash~ to flash it.  Each client must have a unique address:

#+begin_example
sudo tmon-flash --mode=485 --addr=1       # RS-485 client at address 1
sudo tmon-flash --mode=wifi --addr=5      # WiFi client at address 5
#+end_example

The tool auto-detects the serial port, but you can use ~--port=/dev/ttyACM0~ to
override.

*USB port:* The ESP32-S3 DevKitC-1 has two USB-C ports.  Connect to the
*right* one (USB-OTG/JTAG) -- it appears as ~/dev/ttyACM*~.  The left
UART port appears as ~/dev/ttyUSB*~ and may conflict with the USBâ†’485
adapter.  See the [[file:docs/wiring.org][Wiring Reference]] for a diagram.

** First-time flash (new board)

The ESP32-S3 uses its built-in USB-Serial/JTAG interface, which can
drop the connection during large writes.  For a brand-new board, hold
the BOOT button for the entire flash:

1. Hold BOOT.
2. Press and release RST (keep holding BOOT).
3. Run ~tmon-flash~.
4. Release BOOT only after the flash finishes.

Subsequent re-flashes of the same board usually work without this.
If the flash still fails, retry -- the connection is intermittent.

** LED status


The built-in LED on each ESP32 signals operational status:

| Color           | Meaning                           |
|-----------------+-----------------------------------|
| Off             | Normal operation                  |
| Blinking red    | WiFi disconnected (WiFi only)     |
| Blinking green  | Sending readings to server        |
| Blinking yellow | Identify: blinks N times (N=addr) |

Pressing the boot button triggers the identify sequence: the LED
blinks yellow N times, where N is the client address.  This lets you
verify which address a device has after flashing.

* Development

For contributors or anyone making local modifications.

** Build and test

These targets use local venvs and do not require a system-wide install.

#+begin_example
make                  # create venvs + dependencies
make check            # run full testsuite (no hardware needed)
#+end_example

** Run locally

To run the servers on the development environment without installing first:

#+begin_example
make run-server-485   # RS-485 (uses server/tmon.toml --transport rs485)
make run-server-wifi  # WiFi push (uses server/tmon.toml --transport wifi)
make run-panel        # panel with mock data at http://localhost:5000
#+end_example

** Building firmware from source

The pre-built firmware is included in the repository, but if you need to rebuild it (requires [[https://platformio.org/][PlatformIO]] on an x86 machine):

#+begin_example
# On the development machine:
make firmware         # build ESP32 binaries into firmware/
scp -r firmware/ pi:~/tmon/
#+end_example

Then re-run ~sudo make install~ on the Pi to update the installed firmware.

* Documentation

- [[file:docs/protocol.org][Protocol Specification]]
- [[file:docs/wiring.org][Wiring Reference]]
- [[file:docs/storage.org][Storage Specification]]
