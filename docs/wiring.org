#+STARTUP: showall
#+OPTIONS: num:1
#+TITLE: Wiring Reference

This system monitors temperatures across multiple floors using ESP32
clients connected to a Raspberry Pi server.

This document describes how to wire ESP32-S3 clients with NTC
thermistors.  Two transport options connect clients to the server:

| Transport  | Use case             | Server connection |
|------------+----------------------+-------------------|
| RS-485     | Production (default) | USB-RS485 adapter |
| WiFi (UDP) | Wireless alternative | UDP over network  |

Both use the same binary protocol.  Choose based on your setup.
Read the [[file:../README.org][README]] first for an overview of the system.

* Common wiring (all transports)

*Board:* esp32-s3-devkitc-1

Each ESP32 reads up to 4 NTC thermistors through a voltage divider
powered from the board's 3.3V pin.  If you are connecting multiple
ESP32 nodes to a shared RS-485 bus, they must all share a common
ground.

** NTC thermistor inputs

Channels 0 through 3 on GPIO 1 through 4:

*Fewer than 4 thermistors?*  Wire any unused GPIO directly to GND.
The firmware detects this and reports the channel as unavailable.

** NTC voltage divider

Each NTC thermistor is read through a voltage divider against a
fixed 10k-ohm reference resistor.

#+begin_example
3.3V
 |
[10k fixed resistor]
 |
 +-------> GPIO 1/2/3/4 (ADC input)
 |
[NTC thermistor]
 |
GND
#+end_example

With this arrangement (fixed resistor on the high side, NTC on the
low side), the ADC voltage decreases as temperature rises (NTC
resistance drops).

*Component values:*

- NTC thermistor: 10k ohm at 25 C (standard B=3950 type).
- Reference resistor: 10k ohm, 1% tolerance.

*Optional:* a 100 nF ceramic capacitor from the ADC input to GND
can reduce noise on the reading.

* Transport: RS-485 (default)

** Pin assignments

| ESP32 Pin        | Connects to           |
|------------------+-----------------------|
| GPIO 17 (TX)     | MAX485 DI             |
| GPIO 16 (RX)     | MAX485 RO             |
| GPIO 5  (DE/RE)  | MAX485 DE + RE (tied) |

** MAX485 wiring

The MAX485 is a half-duplex RS-485 transceiver.  DE and RE are tied
together so a single GPIO controls bus direction.

#+begin_example
ESP32                MAX485               RS-485 bus
-----                ------               ----------
GPIO 17 (TX) ------> DI
GPIO 16 (RX) <------ RO
GPIO  5      ------> DE + RE (tied)
                      A  ------------->  A
                      B  ------------->  B
             GND ---- GND ------------>  GND
             3.3V --- VCC
#+end_example

*DE/RE signal:* HIGH = transmit, LOW = receive.

** Bus topology

All nodes (server USB adapter + ESP32 clients) share a single
twisted pair plus ground.

#+begin_example
Pi (USB-RS485)       Client 1        Client 2        Client N
   A ----+-----------+- A --+---------+- A --+-- ... --+- A
   B ----+-----------+- B --+---------+- B --+-- ... --+- B
  GND ---+-----------+- GND-+---------+- GND-+-- ... --+- GND
         |                                              |
      [120R]                                         [120R]
      (term.)                                        (term.)
#+end_example

- Use twisted pair cable for A/B.  Run a separate ground wire.
- 120-ohm termination resistors at both physical ends of the bus.
- Keep the bus under 30 meters for a home installation; this is
  well within RS-485 limits.
- At 9600 baud there is generous margin for cable length and noise.

** Bias resistors (optional -- skip for most home installs)

For a short home bus you can skip this section entirely.  The protocol
uses CRC error checking and the poll loop retries automatically, so
occasional noise on the bus is harmless.  Only add bias resistors if
you see frequent CRC errors in the server log.

*What they do:* When no device is transmitting, the A/B lines float
and electrical noise can produce garbage bytes.  Two 560-ohm resistors
at the server end hold the bus in a known-good idle state: one pulls A
toward VCC, the other pulls B toward GND.

Shown for the MAX485 (A is the high line at idle):

#+begin_example
         VCC (3.3V or 5V)
          |
        [560R]  pull-up
          |
  A --+---+---+-- bus continues ...
      |       |
   [120R]     |
   (term.)    |
      |       |
  B --+---+---+-- bus continues ...
          |
        [560R]  pull-down
          |
         GND
#+end_example

Check your transceiver datasheet if you are not using a MAX485 -- A/B
naming varies between manufacturers.

** Server side

The server uses a USB-to-RS-485 adapter.  No additional wiring is
needed on the Pi beyond plugging in the adapter and connecting A, B,
GND to the bus.

Most USB-RS485 adapters have a built-in 120-ohm termination resistor.
If using such an adapter at one end of the bus, you only need to add
an external termination resistor at the other end.

The adapter typically appears as ~/dev/ttyUSB0~.

** Testing without the MAX485 module

You can test the full RS-485 firmware path without any transceiver
hardware.  Wire the ESP32 UART pins (GPIO 17 TX, GPIO 16 RX) directly
to the Pi's GPIO UART, crossing TX/RX as usual:

- ESP32 GPIO 17 (TX) --> Pi GPIO 15 / pin 10 (RX)
- ESP32 GPIO 16 (RX) <-- Pi GPIO 14 / pin 8  (TX)

Leave GPIO 5 (DE/RE) unconnected -- the firmware toggles it but
nothing reads it without a transceiver on the other end.

To enable the Pi's GPIO UART, disable Bluetooth (which shares the
UART) and the serial console:

1. Edit ~/boot/firmware/config.txt~:
   #+begin_example
   enable_uart=1
   dtoverlay=disable-bt
   #+end_example

2. Edit ~/boot/firmware/cmdline.txt~: remove ~console=serial0,115200~
   if present.

3. Reboot.  ~/dev/serial0~ is now available on GPIO 14 / pin 8 (TX)
   and GPIO 15 / pin 10 (RX).

* Transport: WiFi (UDP push)

WiFi clients need only the common wiring (thermistors + power) -- no
MAX485 module, no UART wiring, no bus cable.  The ESP32 connects to
your WiFi network and pushes readings to the server over UDP.

WiFi credentials are configured in ~/etc/tmon/wifi.toml~ (copy from
~wifi.toml.example~ and fill in your SSID and password).  See the
[[file:../README.org][README]] for configuration details.

* Parts list (reference setup)

This bill of materials covers the reference setup: 3 floors with 4
thermistors per floor, using RS-485 transport.

** Client nodes (3 total, one per floor)

| Qty | Part                      | Notes                          |
|-----+---------------------------+--------------------------------|
|   3 | ESP32-S3-DevKitC-1        | Must be S3 variant (see below) |
|   3 | MAX485 module             | 1 per ESP32 (RS-485 only)      |
|  12 | 10k ohm 1% resistor       | 4 per floor (voltage dividers) |
|  12 | 10k NTC thermistor        | 4 per floor (B=3950 type)      |
|  12 | 100nF ceramic capacitor   | 4 per floor (optional, noise)  |

*Why ESP32-S3?*  The pre-built firmware and the ~tmon-flash~ tool
target the S3 specifically.  Other ESP32 variants (original, C3, S2)
are not compatible without rebuilding from source.

** Server (Raspberry Pi)

| Qty | Part                | Notes                                  |
|-----+---------------------+----------------------------------------|
|   1 | USB-to-RS485 adapter | Most have built-in 120 ohm termination |

** RS-485 bus

| Qty | Part               | Notes                                   |
|-----+--------------------+-----------------------------------------|
|   1 | 120 ohm resistor   | Far-end termination (adapter has one)   |
|   - | Twisted pair cable | A/B lines, length as needed             |
|   - | Ground wire        | Run alongside twisted pair              |
