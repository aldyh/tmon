#+STARTUP: showall
* Wiring Reference

This system monitors temperatures across multiple floors using ESP32
sensor nodes connected to a Raspberry Pi server.

This document describes how to wire ESP32-S3 sensor nodes with NTC
thermistors.  Three transport options connect sensors to the server:

| Transport  | Use case                | Server connection        |
|------------+-------------------------+--------------------------|
| RS-485     | Production (default)    | USB-RS485 adapter        |
| Bare UART  | Testing without RS-485  | Pi GPIO UART             |
| WiFi (UDP) | Wireless alternative    | UDP over network         |

All three use the same binary protocol.  Choose based on your setup.

** Common wiring (all transports)

*Board:* esp32-s3-devkitc-1

All nodes must share a common ground.

*** NTC thermistor inputs

| Function       | ESP32 GPIO | Notes    |
|----------------+------------+----------|
| NTC channel 0  | GPIO 1     | ADC1_CH0 |
| NTC channel 1  | GPIO 2     | ADC1_CH1 |
| NTC channel 2  | GPIO 3     | ADC1_CH2 |
| NTC channel 3  | GPIO 4     | ADC1_CH3 |

*Why ADC1?*  ADC2 cannot be used while WiFi is active.  All
thermistor inputs are on ADC1 so WiFi remains available if needed.

*Unused channels:* To permanently disable a channel, wire the GPIO
directly to GND.  The firmware detects this and reports the channel as
unavailable.

*** NTC voltage divider

Each NTC thermistor is read through a voltage divider against a
fixed 10k-ohm reference resistor.

#+begin_example
3.3V
 |
[10k fixed resistor]
 |
 +-------> GPIO 1/2/3/4 (ADC input)
 |
[NTC thermistor]
 |
GND
#+end_example

With this arrangement (fixed resistor on the high side, NTC on the
low side), the ADC voltage decreases as temperature rises (NTC
resistance drops).

*Component values:*

- NTC thermistor: 10k ohm at 25 C (standard B=3950 type).
- Reference resistor: 10k ohm, 1% tolerance.

*Optional:* a 100 nF ceramic capacitor from the ADC input to GND
can reduce noise on the reading.

*** Status LED

The ESP32-S3-DevKitC-1 has a built-in RGB LED.  Both firmware versions
use it for the identify function; the UDP firmware also uses it for
WiFi status.

| Color            | Meaning                            |
|------------------+------------------------------------|
| Off              | Normal operation                   |
| Blinking red     | WiFi disconnected (UDP only)       |
| Blinking green   | Sent reading (both firmwares)       |
| Blinking yellow  | Identify: blinks N times (N=ADDR)  |

The UDP firmware blinks red on boot until WiFi connects, and again
if the connection drops mid-operation.  Retries every 10 seconds.

*** Boot button

Pressing the boot button (GPIO 0) triggers the identify sequence:
the LED blinks yellow N times, where N is the sensor address.  This
lets an installer verify which address a device has after flashing.
Both firmware versions support this.

** Transport: RS-485 (default)

*** Pin assignments

| Function     | ESP32 GPIO | Notes                      |
|--------------+------------+----------------------------|
| UART TX      | GPIO 17    | To MAX485 DI               |
| UART RX      | GPIO 16    | From MAX485 RO             |
| RS-485 DE/RE | GPIO 5     | To MAX485 DE and RE (tied) |

*** MAX485 wiring

The MAX485 is a half-duplex RS-485 transceiver.  DE and RE are tied
together so a single GPIO controls bus direction.

#+begin_example
ESP32                MAX485               RS-485 bus
-----                ------               ----------
GPIO 17 (TX) ------> DI
GPIO 16 (RX) <------ RO
GPIO  5      ------> DE + RE (tied)
                      A  ------------->  A
                      B  ------------->  B
             GND ---- GND ------------>  GND
             3.3V --- VCC
#+end_example

*DE/RE signal:* HIGH = transmit, LOW = receive.

*** Bus topology

All nodes (server USB adapter + ESP32 sensors) share a single
twisted pair plus ground.

#+begin_example
Pi (USB-RS485)       Sensor 1        Sensor 2        Sensor N
   A ----+-----------+- A --+---------+- A --+-- ... --+- A
   B ----+-----------+- B --+---------+- B --+-- ... --+- B
  GND ---+-----------+- GND-+---------+- GND-+-- ... --+- GND
         |                                              |
      [120R]                                         [120R]
      (term.)                                        (term.)
#+end_example

- Use twisted pair cable for A/B.  Run a separate ground wire.
- 120-ohm termination resistors at both physical ends of the bus.
- Keep the bus under 30 meters for a home installation; this is
  well within RS-485 limits.
- At 9600 baud there is generous margin for cable length and noise.

*** Bias resistors (optional)

When the bus is idle (between poll cycles), no device drives the A/B
lines and they float.  Electrical noise can produce garbage bytes.

Failsafe biasing holds the bus in the UART idle state (mark) by
pulling the idle-high line toward VCC and the other toward GND with
560 ohm resistors at the server end.  A/B naming varies between
manufacturers -- check your transceiver datasheet for which line is
high at idle.

Shown for MAX485 convention (A high at idle):

#+begin_example
         VCC (3.3V or 5V)
          |
        [560R]  pull-up
          |
  A --+---+---+-- bus continues ...
      |       |
   [120R]     |
   (term.)    |
      |       |
  B --+---+---+-- bus continues ...
          |
        [560R]  pull-down
          |
         GND
#+end_example

For a short home bus you can skip these.  CRC catches any garbage
and the poll loop self-heals within seconds.  Add them only if you
see frequent CRC errors.

*** Server side

The server uses a USB-to-RS-485 adapter.  No additional wiring is
needed on the Pi beyond plugging in the adapter and connecting A, B,
GND to the bus.

Most USB-RS485 adapters have a built-in 120-ohm termination resistor.
If using such an adapter at one end of the bus, you only need to add
an external termination resistor at the other end.

The adapter typically appears as ~/dev/ttyUSB0~.

** Transport: Bare UART (testing)

The sensor firmware can be tested without RS-485 transceivers by
connecting the ESP32 UART directly to the Pi's GPIO UART.  No code
changes are required.

*Why this works:* The DE/RE pin (GPIO 5) is configured as output-only.
The firmware toggles it, but nothing ever reads it.  When left
floating, the GPIO simply switches into thin air.  The UART bytes flow
identically whether they pass through a MAX485 or over a direct wire.

*** Pin assignments

| Function     | ESP32 GPIO | Notes                   |
|--------------+------------+-------------------------|
| UART TX      | GPIO 17    | Connect to test UART RX |
| UART RX      | GPIO 16    | Connect to test UART TX |
| RS-485 DE/RE | GPIO 5     | Leave floating          |

Once testing passes, move the wires to the MAX485 module
(GPIO 17 -> DI, GPIO 16 <- RO, GPIO 5 -> DE+RE).

*** Pi GPIO UART

The Pi's GPIO UART can provide a direct serial connection for testing.
This requires disabling Bluetooth (which uses the same UART) and the
serial console.

1. Edit ~/boot/firmware/config.txt~:
   #+begin_example
   enable_uart=1
   dtoverlay=disable-bt
   #+end_example

2. Edit ~/boot/firmware/cmdline.txt~: remove ~console=serial0,115200~
   if present.

3. Reboot.  ~/dev/serial0~ is now available on GPIO 14 (TX) / GPIO 15
   (RX).

** Transport: WiFi (UDP push)

The sensor firmware can use WiFi instead of RS-485.  In this mode the
ESP32 stays connected to WiFi and pushes readings to the server over
UDP at a regular interval.

WiFi sensors use the following from the common wiring section:
- Power: 3.3V and GND
- NTC thermistor inputs (GPIO 1-4) with voltage dividers
- Status LED (built-in, no wiring needed)

The UART pins (GPIO 16/17) and RS-485 pins (GPIO 5, MAX485 module)
are unused.

WiFi credentials are read from ~server/wifi.toml~ (copy from
~wifi.toml.example~).

** Parts list (reference setup)

This bill of materials covers the reference setup: 3 floors with 4
thermistors per floor, using RS-485 transport.

*** Sensor nodes (3 total, one per floor)

| Qty | Part                      | Notes                          |
|-----+---------------------------+--------------------------------|
|   3 | ESP32-S3-DevKitC-1        | Must be S3 variant (see below) |
|   3 | MAX485 module             | 1 per ESP32 (RS-485 only)      |
|  12 | 10k ohm 1% resistor       | 4 per floor (voltage dividers) |
|  12 | 10k NTC thermistor        | 4 per floor (B=3950 type)      |
|  12 | 100nF ceramic capacitor   | 4 per floor (optional, noise)  |

*Why ESP32-S3?*  The firmware, partition table, and flash tool
(~tmon-flash~) are built for ESP32-S3.  Other ESP32 variants (original,
C3, S2) have different bootloader offsets and pin mappings.  Using a
different chip requires changes to ~platformio.ini~, ~tmon-flash~, and
the pin assignments above.

*** Server (Raspberry Pi)

| Qty | Part                | Notes                                  |
|-----+---------------------+----------------------------------------|
|   1 | USB-to-RS485 adapter | Most have built-in 120 ohm termination |

*** RS-485 bus

| Qty | Part               | Notes                                   |
|-----+--------------------+-----------------------------------------|
|   1 | 120 ohm resistor   | Far-end termination (adapter has one)   |
|   - | Twisted pair cable | A/B lines, length as needed             |
|   - | Ground wire        | Run alongside twisted pair              |
