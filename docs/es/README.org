#+STARTUP: showall
#+OPTIONS: num:1
#+TITLE: tmon: Un sistema de monitoreo de temperatura

* Resumen

Un sistema compacto *Raspberry Pi + ESP32* para monitorear
temperaturas a través de *RS-485* o *WiFi*.

- *Servidor (Raspberry Pi):* Daemon en Python que recopila lecturas de los clientes ESP32 y las almacena en una base de datos SQLite.
- *Transporte:* RS-485 (adaptador USB, el servidor consulta) o WiFi (los clientes envían por UDP).
- *Clientes (ESP32):* Cada uno lee hasta *4 termistores NTC*.  Solo la versión S3-DevKitC-1 ha sido probada; el firmware precompilado apunta a este modelo.
- *Protocolo:* Tramas binarias simples con *CRC-16/MODBUS*.

Tres servicios se ejecutan en la Pi: un daemon RS-485 que consulta clientes RS-485, un daemon WiFi que recibe datos de clientes WiFi, y un panel web.  Se pueden combinar modos de transporte, pero cada cliente debe tener una dirección única (ver [[#flashing-client-firmware][Flashear firmware del cliente]]).  Las lecturas se almacenan en una base de datos SQLite (ver [[file:storage.org][Especificación de almacenamiento]]) y se visualizan desde el panel web.

* Arquitectura

#+begin_example
                Raspberry Pi
  .-------------------------------------------.
  |  Servidor RS-485     (tmond-485)           |
  |  Servidor WiFi       (tmond-wifi)          |
  |  Panel web           (tmon-panel)          |
  |  Base de datos        (tmon.db)            |
  '-+---------------------------------------+-'
    |                                       |
    |  Bus RS-485                    WiFi (UDP)
    |                                       |
    +--+-------+-------+          +---------+---------+
       |       |       |          |                   |
     +---+   +---+   +---+      +---+               +---+
     | 1 |   | 4 |   | 5 |      | 2 |               | 3 |
     +---+   +---+   +---+      +---+               +---+

  [N] = Cliente ESP32 en la dirección N (hasta 4 termistores NTC cada uno)
#+end_example

Consulte la [[file:wiring.org][Referencia de cableado]] para saber cómo conectar los clientes ESP32, los termistores y el bus RS-485.

* Instalación
:PROPERTIES:
:CUSTOM_ID: installation
:END:

La instalación está pensada para realizarse en la Raspberry Pi.  El
instalador guía la configuración e inicia los servicios:

#+begin_example
# En la Pi:
git clone https://github.com/aldyh/tmon.git
cd tmon
make
sudo make install
#+end_example

El instalador solicita el puerto RS-485, las direcciones de clientes,
el intervalo de consulta y (opcionalmente) la configuración WiFi.
Escribe los archivos de configuración, instala todo e inicia los
servicios -- no se necesita edición manual.

Al ejecutar ~sudo make install~ nuevamente se sobreescribe la
configuración anterior.

** Desinstalación

#+begin_example
sudo make uninstall
#+end_example

** Configuración manual

Para usuarios avanzados que deseen editar la configuración directamente:

- ~/etc/tmon/tmon.toml~ -- puerto RS-485, direcciones de clientes, intervalo de consulta, puerto WiFi
- ~/etc/tmon/wifi.toml~ -- credenciales WiFi (SSID, contraseña, IP del servidor)

Después de editar, reinicie el servicio correspondiente:

#+begin_example
sudo systemctl restart tmond-485          # después de cambiar configuración [rs485]
sudo systemctl restart tmond-wifi         # después de cambiar [wifi] o wifi.toml
#+end_example

** Logs

#+begin_example
journalctl -u tmond-485 -f       # Ver lecturas RS-485 a medida que llegan.
journalctl -u tmond-wifi -f      # Ver lecturas WiFi a medida que llegan.
#+end_example

* Flashear firmware del cliente
:PROPERTIES:
:CUSTOM_ID: flashing-client-firmware
:END:

Conecte un ESP32 a la Pi vía USB, luego use ~tmon-flash~ para flashearlo.  Cada cliente debe tener una dirección única:

#+begin_example
tmon-flash --mode=485 --addr=1             # cliente RS-485 en la dirección 1
tmon-flash --mode=wifi   --addr=5          # cliente WiFi en la dirección 5
#+end_example

La herramienta detecta automáticamente el puerto, pero se puede usar ~--port=/dev/ttyACM0~ para especificarlo manualmente.

** Primera vez (placa nueva)

El ESP32-S3 usa su interfaz USB-Serial/JTAG integrada, que puede
perder la conexión durante escrituras grandes.  Para una placa nueva,
mantenga presionado el botón BOOT durante todo el flasheo:

1. Mantenga presionado BOOT.
2. Presione y suelte RST (siga presionando BOOT).
3. Ejecute ~tmon-flash~.
4. Suelte BOOT solo cuando el flasheo termine.

Los re-flasheos posteriores generalmente funcionan sin esto.
Si el flasheo falla, reintente -- la conexión es intermitente.

** Estado del LED


El LED integrado en cada ESP32 indica el estado operativo:

| Color                | Significado                                   |
|----------------------+-----------------------------------------------|
| Apagado              | Operación normal                              |
| Rojo parpadeante     | WiFi desconectado (solo WiFi)                 |
| Verde parpadeante    | Enviando lecturas al servidor                 |
| Amarillo parpadeante | Identificar: parpadea N veces (N=dirección)   |

Presionar el botón boot activa la secuencia de identificación: el LED
parpadea en amarillo N veces, donde N es la dirección del cliente.
Esto permite verificar qué dirección tiene un dispositivo después de
flashearlo.

* Desarrollo

Para colaboradores o cualquiera que haga modificaciones locales.

** Compilación y pruebas

Estos targets usan venvs locales y no requieren una instalación a nivel de sistema.

#+begin_example
make                  # crear venvs + dependencias
make check            # ejecutar suite de pruebas completa (no se necesita hardware)
#+end_example

** Ejecutar localmente

Para ejecutar los servidores en el entorno de desarrollo sin instalar primero:

#+begin_example
make run-server-485   # RS-485 (usa server/tmon.toml --transport rs485)
make run-server-wifi  # WiFi push (usa server/tmon.toml --transport wifi)
make run-panel        # panel con datos simulados en http://localhost:5000
#+end_example

** Compilar firmware desde el código fuente

El firmware precompilado está incluido en el repositorio, pero si necesita recompilarlo (requiere [[https://platformio.org/][PlatformIO]] en una máquina x86):

#+begin_example
# En la máquina de desarrollo:
make firmware         # compilar binarios ESP32 en firmware/
scp -r firmware/ pi:~/tmon/
#+end_example

Luego ejecute ~sudo make install~ nuevamente en la Pi para actualizar el firmware instalado.

* Documentación

- [[file:protocol.org][Especificación del protocolo]]
- [[file:wiring.org][Referencia de cableado]]
- [[file:storage.org][Especificación de almacenamiento]]
