#+STARTUP: showall

* Web panel: visualization options

** About this document

This file is exploratory -- the reader (or system) is free to ignore it
entirely.  It documents a few approaches for adding a web-based
dashboard to tmon so that temperature readings can be viewed in a
browser.  The project will eventually need some visualization layer on
top of the SQLite data store; these are the options considered.

** What we want to show

- *Live view:* current (most recent) temperature for every
  slave/channel, updated automatically.
- *Historical view:* line charts of temperature over time, filterable
  by slave, channel, and time range.
- *Status indicators:* whether a slave is responding or offline
  (inferred from missing recent readings).

The data source is the existing ~readings~ SQLite table (see
~docs/storage.org~).  The system is small: 1-4 slaves, up to 4
channels each, one reading per slave every ~30 seconds.

** Option A: Flask + HTMX (server-rendered, minimal JS)

A lightweight Python web server reads SQLite directly and renders HTML.
HTMX handles live updates by polling an endpoint and swapping page
fragments -- no custom JavaScript needed for the interactive parts.
Charts are rendered server-side as SVG (e.g. with ~pygal~) or as
static images (e.g. with ~matplotlib~).

*** Architecture

#+begin_example
Browser  <--HTTP-->  Flask app  <--SQL-->  tmon.db (SQLite, WAL)
#+end_example

- Flask serves HTML templates (Jinja2).
- HTMX attributes on elements (~hx-get~, ~hx-trigger="every 10s"~)
  auto-refresh the live-readings table.
- Historical charts: an endpoint returns an SVG chart for a given
  slave/channel/time-range; the browser displays it as an ~<img>~.

*** Pros

- Extremely small JS footprint (HTMX is a single ~14 KB file).
- All logic lives in Python -- one language, one process.
- Easy to test: Flask test client + standard pytest.
- pygal produces clean, interactive SVGs with hover tooltips natively.
- No build step, no node_modules, no bundler.

*** Cons

- Server-rendered charts are less interactive than JS charting
  libraries (no client-side zoom/pan without extra work).
- HTMX polling is simple but not real-time (10-30 s refresh is fine
  here; WebSockets would be overkill).
- pygal is a niche library; matplotlib SVG output is an alternative
  but produces larger files.

** Option B: Flask + Chart.js (server API, client-rendered charts)

Same Flask backend, but it exposes a small JSON API.  The frontend is
a single HTML page that uses Chart.js to draw interactive line charts
in the browser.

*** Architecture

#+begin_example
Browser (Chart.js)  <--JSON API-->  Flask app  <--SQL-->  tmon.db
#+end_example

- Flask serves one static HTML page plus a few API endpoints:
  - ~GET /api/current~ -- latest reading per slave.
  - ~GET /api/history?addr=N&hours=H~ -- historical readings.
- Chart.js renders line charts on a ~<canvas>~.
- A small ~<script>~ fetches ~/api/current~ every 10 s and updates
  a readings table + chart.

*** Pros

- Chart.js is mature, well-documented, and widely used (~200 KB).
- Client-side rendering gives smooth zoom, pan, and tooltip
  interaction out of the box.
- JSON API is reusable (other tools or scripts can query it).
- Still no build step -- Chart.js can be loaded from a CDN or
  vendored as a single file.

*** Cons

- More JavaScript than Option A (a few dozen lines of fetch + chart
  setup, but still modest).
- Two rendering layers to reason about (Python API + JS frontend).
- Chart.js is a runtime dependency that must be kept up to date
  (or vendored/pinned).

** Option C: Grafana + JSON or SQLite plugin

Grafana is a full-featured dashboarding tool.  A plugin reads
the SQLite database (or a thin JSON data-source wrapper) and Grafana
handles all visualization, alerting, and user management.

*** Architecture

#+begin_example
Browser  <--HTTP-->  Grafana  <--plugin-->  tmon.db
#+end_example

- Install Grafana OSS on the Pi (or another host with access to
  the database file).
- Use the community SQLite datasource plugin, or write a small
  Flask/FastAPI shim that speaks the Grafana JSON datasource protocol.
- Build dashboards in the Grafana UI.

*** Pros

- Extremely rich visualization: annotations, alerts, templating,
  multi-panel layouts.
- No custom frontend code at all.
- Battle-tested for exactly this kind of time-series monitoring.

*** Cons

- Heavy dependency: Grafana is a large Go binary with its own
  database, user model, and upgrade cycle -- disproportionate for
  1-4 sensors.
- The SQLite plugin is community-maintained and may lag behind
  Grafana releases.
- Configuration is done in the Grafana UI, not in version-controlled
  files (unless you also adopt provisioning YAML).
- Harder to keep the "small, self-contained project" character.

** Comparison

| Criterion            | A: Flask + HTMX     | B: Flask + Chart.js  | C: Grafana           |
|----------------------+----------------------+----------------------+----------------------|
| External deps        | Flask, pygal, HTMX   | Flask, Chart.js      | Grafana, plugin      |
| JS complexity        | Near zero            | Low (~50 lines)      | None (Grafana UI)    |
| Chart interactivity  | Basic (SVG hover)    | Good (zoom/pan)      | Excellent            |
| Maintainability      | High (all Python)    | High (thin JS layer) | Medium (external)    |
| Testability          | Easy (Flask client)  | Easy (API tests)     | Hard (Grafana setup) |
| Fits project style   | Yes                  | Yes                  | Not really           |
| Setup effort         | Low                  | Low                  | Medium-high          |

** Recommendation

Options A and B are both good fits.  Option B (Flask + Chart.js)
is the sweet spot: the JSON API keeps the backend clean and testable,
Chart.js gives smooth interactive charts with minimal code, and there
is no build tooling.  Option A is the fallback if we want to avoid
client-side JavaScript entirely.  Option C is noted for completeness
but is too heavy for this project.
