#+STARTUP: showall

* Project plan

Goal: a small, robust temperature monitoring system where a Raspberry Pi polls a few ESP32 nodes over RS-485, stores readings locally, and is easy to test without hardware.

** Assumptions

- 1-4 ESP32 slaves, each with up to 4 NTC thermistors.
- A USB <-> RS-485 adapter on the Pi.
- SQLite is sufficient
- Protocol is custom binary as defined in ~docs/protocol.org~.

** Conventions

- *Python (master):* Python 3.11+, minimal deps (prefer stdlib; ~pyserial~ is expected).
- *Config:* ~config-485.toml~, ~config-udp.toml~ (stdlib ~tomllib~ in Python 3.11).
- *Testing:*
  - Unit tests: ~pytest~ with fakes/mocks (no hardware).
  - Integration tests: ~socat~ + serial simulator (~master/tools~).
- *Firmware (slave):* PlatformIO + Arduino framework; keep firmware straightforward.

** Milestones

Use this as the canonical checklist. Keep it up to date as work is completed.

*** Setup coding guidelines
- [X] Coding guidlines are GNU for C/C++.  Look up what that means, especially space after function
names.  Braces on lone line, but are indented one more level.  typedef/struct have braces
on next line, but on column 0.  Look it up.
- [X] For python document each method/class with docstrings.
- [X] Document each argument and retval.
- [X] For main API methods, and toplevel externally visible functions include usage/code examples.
- [X] Update CLAUDE.md to include coding guidelines accordingly described above.

*** Flesh out docs/wiring.org

- [X] Document the wiring for the esp32.

*** Flesh out docs/protocol.org

- [X] Design protocol.  Remember this is not meant to grow in complexity,
so something simple.
- [X] Write out docs/protocol.org.
- [X] Favor clean, elegant, to the point.
- [X] Provide examples.
- [X] Explain that it's crc-16/modbus.
- [X] Remove modbus reference from PLAN.org.

*** Flesh out docs/storage.org

- [X] document schema and how poll data will be stored in sqlite in docs/storage.org
- [X] update README.org to link to docs/storage.org

*** Setup skeleton test

- [X] Setup bare stubs for entire project (no API, just stubs)
- [X] Add stub tests so that we can "run" tests for slave, master, etc, even if just placeholders.
- [X] We can build the entire system and tests pass.
- [X] Flesh out "Quick Start" section in README.org.

*** Protocol layer (Python)

- [X] Implement frame encode/decode per ~docs/protocol.org~
- [X] Implement CRC-16/MODBUS
- [X] Validate length/fields; reject malformed frames cleanly
- [X] Unit tests: round-trip encode/decode, CRC pass/fail, fuzz-ish malformed inputs
- [X] Public API: minimal and stable (e.g., ~encode_request(...)~, ~decode_frame(...)~)

*** Protocol layer (ESP32)

- [X] Implement the same framing + CRC in firmware
- [X] Unit-test-ish coverage where feasible (host-side tests or embedded tests if lightweight)
- [X] Ensure consistent endianness/field sizes with Python implementation
- [X] Use unity for testing protocol while hardware becomes available.
- [X] Unity tests pass on x86 linux box.

*** Unified test runner

- [X] Add root Makefile with ~check~, ~check-master~, ~check-slave~ targets
- [X] Simplify README.org testing section to point at ~make check~
- [X] Add ~all~, ~build-master~, ~build-slave~ targets to Makefile
- [X] Rewrite README Quick Start to use make targets

*** Simulator (x86)

- [X] Implement a simple "virtual slave" that speaks the protocol over a pseudo-serial port
- [X] Integration test: master talks to simulator and receives stable readings
- [X] Master can poll simulator end-to-end without hardware

*** Master poller loop

- [X] Implement serial bus abstraction
- [X] Poll loop
- [X] Unit tests around poll scheduling and timeout behavior using fake bus
- [X] Poller can run against simulator

*** Storage (SQLite)

- [X] Define schema
- [X] Write path: insert readings efficiently
- [X] Basic query helpers
- [X] Integration test: poller -> storage using simulator
- [X] SQLite DB gets populated correctly during simulator run

*** Master daemon

- [X] Config-driven entry point (~tmon~ console script via pyproject.toml)
- [X] Run poll loop on a configurable schedule
- [X] Logging (stdlib ~logging~)
- [X] Clean shutdown on SIGINT/SIGTERM
- [X] Integration test: daemon starts, polls simulator, stores readings, shuts down cleanly

*** Demo visualization panel

- [X] Directory structure, pyproject.toml, Makefile targets
- [X] Vendor Chart.js
- [X] Data generation script + tests
- [X] Flask API endpoints + tests
- [X] Frontend: index.html + style.css (working dashboard)
- [X] Documentation (panel/README.org, PLAN.org, TODO.org)

*** Static demo builder

- [X] ~build_demo.py~: generates static HTML/JSON/CSV from ~tmon_mock.db~
- [X] Tests for all output files, JSON/CSV content, HTML transforms
- [X] Makefile targets: ~demo-static~, ~demo-static-tar~, ~demo-static-clean~
- [X] Documentation (panel/README.org, PLAN.org)

*** ESP32 firmware: sensors + RS-485

**** Blink test (verify toolchain)
- [X] Update platformio.ini for ESP32-S3
- [X] Blink sketch compiles and uploads
- [X] GPIO toggles on real hardware

**** Bare UART test (GPIO-to-GPIO, no RS485)
- [X] Document Pi UART setup in docs/wiring.org (disable BT, enable UART)
- [X] Firmware: configure UART on GPIO 16/17, toggle DE/RE on GPIO 5
- [X] Superseded by UDP transport; hardware validation moved to "Hardware bring-up" milestone

*** UDP push transport (alternative to RS-485)

- [X] Master: UDPReceiver implementation
- [X] Master: Listener for decoding/storing
- [X] Master: Config transport selection (rs485 or udp)
- [X] Master: UDP integration tests
- [X] Slave: NTC thermistor reading (Steinhart-Hart)
- [X] Slave: UDP push with deep sleep
- [X] Slave: Build environments (uart vs udp)
- [X] Makefile targets for UDP builds
- [X] Remove obsolete TCP WiFi transport

*** Production directory layout and config resolution

Before anything can be installed, the code needs to know where to find
config and data in both dev and production contexts.

- [X] Define layout: ~/etc/tmon/~ for config, ~/var/lib/tmon/~ for data + firmware
- [X] Config path resolution: check repo-local first, fall back to ~/etc/tmon/~
- [X] Database path: repo-local ~tmon.db~ for dev, ~/var/lib/tmon/tmon.db~ for production
- [X] Panel reads DB from same resolved path (no separate config needed)

*** Deployment and installation

Full automation: ~make install~ runs ~install.sh~ which handles everything.

- [X] ~install.sh~: create ~tmon~ user, create ~/etc/tmon/~ and ~/var/lib/tmon/~
- [X] ~install.sh~: pip install master package, copy config files
- [X] ~install.sh~: install firmware binaries to ~/var/lib/tmon/firmware/~
- [X] systemd service files: ~tmond-serial.service~, ~tmond-udp.service~
- [X] systemd service file: ~tmon-panel.service~ (gunicorn serving Flask app)
- [X] ~install.sh~: enable and start selected services
- [X] ~uninstall.sh~ and ~make uninstall~ target
- [X] ~make install~ target that invokes ~install.sh~

*** Firmware flash tool

Convenience script for flashing ESP32s from the Pi.

- [X] ~tmon-flash~ script: ~--mode={serial,udp} --addr=N~
- [X] Invokes esptool with correct firmware from ~/var/lib/tmon/firmware/~
- [X] Installed by ~install.sh~
- [X] ~make firmware~ target to build all variants

*** Binary-patch configuration

Replace compile-time build flags with binary-patchable marker arrays.
Build 2 generic firmware binaries, patch config at flash time.

- [X] ~config.h~ / ~config.cpp~: marker arrays + ~config_init()~
- [X] ~main_485.cpp~ / ~main_udp.cpp~: use config.h globals, halt if unpatched
- [X] Remove ~slave_addr.py~ and ~wifi_config.py~
- [X] ~deploy/tmon-patch~: find markers, overwrite with real values
- [X] ~tmon-flash~: generic binary name, patch step, TOML reading for UDP
- [X] ~Makefile~: 2 generic builds, ~flash-slave*~ calls ~tmon-flash~
- [X] ~install.sh~: install ~tmon-patch~, generic firmware names

*** Verify installation works on x86

- [X] Verify daemons can run
- [X] Verify daemons can log
- [X] Flash UDP firmware, verify readings arrive at daemons
- [X] Verify daemon stores readings correctly in SQLite
- [X] Verify panel reads SQLite correctly

*** Verify installation works on pi

- [ ] Verify git clone works
- [ ] Verify make install works
- [ ] Verify daemons can run
- [ ] Verify daemons can log
- [ ] Flash UDP firmware, verify readings arrive at daemons
- [ ] Verify daemon stores readings correctly in SQLite
- [ ] Verify panel reads SQLite correctly

*** Hardware bring-up (NTC + UDP smoke test)

First real hardware validation.  Do this over UDP since it avoids
RS-485 wiring complexity.

- [ ] Wire NTC to breadboard on one ESP32
- [ ] Verify temperatures are sane

*** Integration + polish

- [ ] Document how to add a new slave (address + wiring + config)
- [ ] Confirm error handling (CRC errors, timeouts, missing devices) is reasonable
- [X] Check LED behavior sanity (stub vs real hardware alignment)
- [ ] Add readings table index (~CREATE INDEX idx_readings_addr_ts ON readings(addr, ts)~)
- [ ] Verify flashing a brand-new ESP32 works from a deployed Pi (no dev environment)
- [ ] Final pass: remove unused code, clean up comments, ensure docs match behavior

*** Full firmware (RS-485)

- [ ] RS-485 transceiver enable/disable control (DE/RE) with correct timing
- [ ] Respond to requests; populate payload with temperature readings
- [ ] Real device responds reliably on a physical RS-485 bus
- [ ] Real bus smoke test with 1 slave -> then scale to all slaves

*** Rename master/slave to server/client

*Last milestone.*  Only after everything else is stable and working.

- [ ] Rename throughout: code, config, docs, directory names, README
- [ ] Update CLAUDE.md if needed
- [ ] Verify all tests pass after rename
