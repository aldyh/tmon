#+STARTUP: showall

* Project plan

Goal: a small, robust temperature monitoring system where a Raspberry Pi polls a few ESP32 nodes over RS-485, stores readings locally, and is easy to test without hardware.

** Assumptions

- 1-4 ESP32 slaves, each with up to 4 NTC thermistors.
- A USB <-> RS-485 adapter on the Pi.
- SQLite is sufficient
- Protocol is custom binary as defined in ~docs/protocol.org~.

** Conventions

- *Python (master):* Python 3.11+, minimal deps (prefer stdlib; ~pyserial~ is expected).
- *Config:* ~config.toml~ (stdlib ~tomllib~ in Python 3.11).
- *Testing:*
  - Unit tests: ~pytest~ with fakes/mocks (no hardware).
  - Integration tests: ~socat~ + simulator (~master/tools~).
- *Firmware (slave):* PlatformIO + Arduino framework; keep firmware straightforward.

** Milestones

Use this as the canonical checklist. Keep it up to date as work is completed.

*** Setup coding guidelines
- [X] Coding guidlines are GNU for C/C++.  Look up what that means, especially space after function
names.  Braces on lone line, but are indented one more level.  typedef/struct have braces
on next line, but on column 0.  Look it up.
- [X] For python document each method/class with docstrings.
- [X] Document each argument and retval.
- [X] For main API methods, and toplevel externally visible functions include usage/code examples.
- [X] Update CLAUDE.md to include coding guidelines accordingly described above.

*** Flesh out docs/wiring.org

- [X] Document the wiring for the esp32.

*** Flesh out docs/protocol.org

- [X] Design protocol.  Remember this is not meant to grow in complexity,
so something simple.
- [X] Write out docs/protocol.org.
- [X] Favor clean, elegant, to the point.
- [X] Provide examples.
- [X] Explain that it's crc-16/modbus.
- [X] Remove modbus reference from PLAN.org.

*** Flesh out docs/storage.org

- [X] document schema and how poll data will be stored in sqlite in docs/storage.org
- [X] update README.org to link to docs/storage.org

*** Setup skeleton test

- [X] Setup bare stubs for entire project (no API, just stubs)
- [X] Add stub tests so that we can "run" tests for slave, master, etc, even if just placeholders.
- [X] We can build the entire system and tests pass.
- [X] Flesh out "Quick Start" section in README.org.

*** Protocol layer (Python)

- [X] Implement frame encode/decode per ~docs/protocol.org~
- [X] Implement CRC-16/MODBUS
- [X] Validate length/fields; reject malformed frames cleanly
- [X] Unit tests: round-trip encode/decode, CRC pass/fail, fuzz-ish malformed inputs
- [X] Public API: minimal and stable (e.g., ~encode_request(...)~, ~decode_frame(...)~)

*** Protocol layer (ESP32)

- [X] Implement the same framing + CRC in firmware
- [X] Unit-test-ish coverage where feasible (host-side tests or embedded tests if lightweight)
- [X] Ensure consistent endianness/field sizes with Python implementation
- [X] Use unity for testing protocol while hardware becomes available.
- [X] Unity tests pass on x86 linux box.

*** Unified test runner

- [X] Add root Makefile with ~check~, ~check-master~, ~check-slave~ targets
- [X] Simplify README.org testing section to point at ~make check~
- [X] Add ~all~, ~build-master~, ~build-slave~ targets to Makefile
- [X] Rewrite README Quick Start to use make targets

*** Simulator (x86)

- [X] Implement a simple "virtual slave" that speaks the protocol over a pseudo-serial port
- [X] Integration test: master talks to simulator and receives stable readings
- [X] Master can poll simulator end-to-end without hardware

*** Master poller loop

- [X] Implement serial bus abstraction
- [X] Poll loop
- [X] Unit tests around poll scheduling and timeout behavior using fake bus
- [X] Poller can run against simulator

*** Storage (SQLite)

- [X] Define schema
- [X] Write path: insert readings efficiently
- [X] Basic query helpers
- [X] Integration test: poller -> storage using simulator
- [X] SQLite DB gets populated correctly during simulator run

*** Master daemon

- [X] Config-driven entry point (~tmon~ console script via pyproject.toml)
- [X] Run poll loop on a configurable schedule
- [X] Logging (stdlib ~logging~)
- [X] Clean shutdown on SIGINT/SIGTERM
- [X] Integration test: daemon starts, polls simulator, stores readings, shuts down cleanly

*** Demo visualization panel

- [X] Directory structure, pyproject.toml, Makefile targets
- [X] Vendor Chart.js
- [X] Data generation script + tests
- [X] Flask API endpoints + tests
- [X] Frontend: index.html + style.css (working dashboard)
- [X] Documentation (panel/README.org, PLAN.org, TODO.org)

*** Static demo builder

- [X] ~build_demo.py~: generates static HTML/JSON/CSV from ~tmon_mock.db~
- [X] Tests for all output files, JSON/CSV content, HTML transforms
- [X] Makefile targets: ~demo-static~, ~demo-static-tar~, ~demo-static-clean~
- [X] Documentation (panel/README.org, PLAN.org)

*** ESP32 firmware: sensors + RS-485

**** Blink test (verify toolchain)
- [X] Update platformio.ini for ESP32-S3
- [X] Blink sketch compiles and uploads
- [X] GPIO toggles on real hardware

**** Bare UART test (GPIO-to-GPIO, no RS485)
- [X] Document Pi UART setup in docs/wiring.org (disable BT, enable UART)
- [ ] ESP32 UART2 wired directly to Pi UART (TX->RX, RX->TX, GND)
- [X] Firmware: configure UART on GPIO 16/17, toggle DE/RE on GPIO 5
- [ ] Echo test: ESP32 echoes received bytes
- [ ] Protocol test: ESP32 responds to POLL_REQUEST with dummy data
- [ ] Master talks to real ESP32 over /dev/serial0

**** Full firmware
- [ ] Read NTC thermistors
- [ ] RS-485 transceiver enable/disable control (DE/RE) with correct timing
- [ ] Respond to requests; populate payload with temperature readings
- [ ] Real device responds reliably on a physical RS-485 bus

*** UDP push transport (alternative to RS-485)

- [X] Master: UdpBus receiver implementation
- [X] Master: PushCollector for decoding/storing
- [X] Master: Config transport selection (rs485 or udp)
- [X] Master: UDP integration tests
- [X] Slave: NTC thermistor reading (Steinhart-Hart)
- [X] Slave: UDP push with deep sleep
- [X] Slave: Build environments (uart vs udp)
- [X] Makefile targets for UDP builds
- [X] Remove obsolete TCP WiFi transport

*** Integration + polish

- [ ] Real bus smoke test with 1 slave -> then scale to all slaves
- [ ] Document how to add a new slave (address + wiring + config)
- [ ] Confirm error handling (CRC errors, timeouts, missing devices) is reasonable
- [ ] Final pass: remove unused code, ensure docs match behavior
