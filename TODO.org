#+STARTUP: overview

* INSTRUCTIONS
This is your TODO list for the project, apart from milestones which are in PLAN.org.

You can ignore this file unless asked to work on a TODO item.

When asked to work on an item, work on a new branch as per the guidelines in CLAUDE.md.  First, come up with a plan, run it by me first, and when we agree on the approach, start implementing it.

When working on a TODO item, constrain yourself to the item at hand.  No fly-by refactors, etc.

New items go at the bottom of the file.  Work through items top to bottom within the TODO section.

The TODO item itself will contain the instructions itself.

Usual commit guidelines per this project apply as described in CLAUDE.md.

As part of the commit mark the item as DONE in this file, and update any milestones that may need updating in PLAN.org.

Add a subsection in the item named "Notes", of anything interesting that came up during working on this item, that might be useful to keep in the archived DONE item.
* DONE Inconsistent error handling philosophy

The protocol layer uses exceptions (Python) / return codes (C) for
validation errors, but the poller layer silently swallows them:

#+begin_example
# poller.py:87-91
try:
    reply = decode_frame(raw)
except ValueError as exc:
    log.debug("bad frame from slave %d: %s", addr, exc)
    return None
#+end_example

Returning ~None~ for all error conditions (timeout, bad CRC, bad
address, unexpected command) loses information. A caller cannot
distinguish "slave offline" from "slave sent garbage." For a home
project this is acceptable, but it would be a problem at scale.

** Notes
Closed as working as designed.  Returning None for all failure modes
is intentional: callers only need "got data" or "didn't get data";
diagnostic details are logged.  Added a one-line comment in poller.py
documenting this choice.
* DONE Convert markdown files to org mode
Convert all *.md files in the project to .org mode, with the exception of CLAUDE.md
which is needed for convention.

** Notes
Converted README.md, PLAN.md, docs/protocol.md, docs/storage.md, docs/wiring.md.
Updated all cross-references in CLAUDE.md, Python docstrings, and test comments.
* DONE Avoid documenting obvious things
Change coding guidelines in CLAUDE.md to avoid documenting obvious things.  Say, a 3-4 line method shouldn't have extensive documentation. A sentence is fine.  No need to document each arg, etc.

Instead for small methods, just write a small sentence on what the function does, and
put some sort of attr as to what arg types are.  For example:

def _require_str(raw: dict[str, object], key: str) -> None:
    """Validate that *key* exists in *raw* and is a str."""

^^^^ no need to document each and every arg.

Actually, when method is obvious enough, the above format is good enough.

Change all code in project accordingly.

** Notes
Replaced verbose Args/Returns sections with type hints in signatures for
short/obvious methods. Kept Google-style sections on main API functions
(encode_request, decode_frame, parse_reply_payload, load_config, poll,
poll_all, run) but trimmed redundant arg docs where the signature suffices.
Updated CLAUDE.md guidelines to reflect the lighter approach.
* DONE Come up with web panel plan.
Familiarize with entire project, and suggest a few ways to visualize this data.
I'd like a web panel where we can see current readings, and also an option to view historical data.
Give me the 2-3 most useful ways of visualizing this data, and document it in docs/panel.org with clear subsections, explaining each option and what the benefits and drawbacks are in terms of style, maintainability, heavy usage of libraries, etc.

Provide a summary at the top (sub section in org mode) where you explain that the reader/system is free to ignore this entire file as it's just random musings, but do give a hint of where we're going with this project (that we'll need a visualization framework).

** Notes
Documented three options in docs/panel.org:
- A: Flask + HTMX (server-rendered, near-zero JS)
- B: Flask + Chart.js (JSON API + client-rendered charts)
- C: Grafana + SQLite plugin (full dashboarding tool)
Recommended Option B as the best balance of interactivity, simplicity,
and testability.  Option C noted but too heavy for this project.
* DONE Implement mock visualization panel
look at docs/panel.org.  i'm interested in option B, but only to see
how it would feel.  in a branch, work on a mock implementation that
reads from the db in the project (populate it with random reasonable
data for a year worth of readings).  put everything, including
dependencies, in a directory so i can start some sort of server, and
point my web browser at it, and play around with it.  write any design
and notes in this item under the Notes section.

i want to see how stuff would actually look and work.

** Notes
Implemented as Option B (Flask + Chart.js) in panel/ directory.
Self-contained: own venv, own pyproject.toml, no imports from master/.

- ~make demo-server~ generates data and starts the server in one step.
- ~make check-demo~ runs 22 tests (6 for data generation, 16 for API).
- generate_data.py creates ~3M rows (3 slaves, 30s intervals, 365 days).
- Temperature profiles: sinusoidal daily/seasonal cycles + Gaussian noise.
- Slave 3 channel 1 has 5% null rate to exercise null handling.
- Time windows relative to newest DB row, so data always appears live.
- Chart.js vendored at 4.4.7 (~206 KB), no CDN dependency.
- Dark industrial/SCADA theme: navy background, monospace font, flat panels.
* DONE Get rid of "payload" arguments in code base
Even though payload is the right terminology for method arguments, we're always talking about temperatures.
Perhaps rename this to something dealing with temperatures.  Choose something clean, short, and obvious.

This is for the method arguments.  I don't care what you do inside the code...for example tests.

** Notes
Renamed the temperature-specific function and its parameters:
- Function: ~parse_reply_payload~ -> ~parse_reply~ (C: ~tmon_parse_reply_payload~ -> ~tmon_parse_reply~)
- Parameter names (~payload~, ~payload_len~) kept as-is -- the argument is an
  opaque blob, not structured temperature data
- Left protocol-framing names (~encode_request~, ~decode_frame~, constants) unchanged
  since those describe the generic protocol, not temperature data.
* DONE Fix stale protocol.md references in C files
~slave/include/protocol.h~ (line 5) and ~slave/src/protocol.c~ (line 4) still
reference ~docs/protocol.md~ -- should be ~docs/protocol.org~ since the
markdown-to-org conversion.

** Notes
Updated both files to reference docs/protocol.org.
* DONE Poller.poll duplicates parse_reply logic
~poller.py:99-105~ manually unpacks the REPLY payload (struct.unpack loop,
PROTO_TEMP_INVALID check) instead of calling ~parse_reply()~ from
~protocol.py~.  The same logic already exists in ~parse_reply~.  Use it.

** Notes
Modified poll() to call parse_reply() and convert temperatures back to raw
int16 values (multiply by 10). Removed unused struct import.
* DONE Deduplicate _make_reply test helper
~master/tests/test_poller.py:16~ and ~master/tests/test_daemon.py:13~ define
identical ~_make_reply(addr, t0, t1, t2, t3)~ helpers.  Move to ~conftest.py~.

** Notes
Moved helper to conftest.py as make_reply() (without underscore prefix since
it's now shared). Updated imports in test_poller.py and test_daemon.py.
* DONE Remove unused import sys in generate_data.py
~panel/generate_data.py~ imports ~sys~ (line 20) but never uses it.

** Notes
Removed the unused import.
* DONE Move datetime imports to module level
~panel/app.py~ imports ~from datetime import ...~ inside two route functions
(lines 110, 179).  ~panel/build_demo.py~ does the same (lines 89, 128).
Move to the top of each file.

** Notes
Moved datetime/timedelta/timezone imports to module level in both files.
* DONE Trim verbose docstrings on test doubles
The "avoid documenting obvious things" cleanup (branch 012) didn't reach
test code.  These test helpers still have full Args/Returns sections on
one-line methods:
- ~master/tests/conftest.py~: FakeBus.send, .receive, .__init__
- ~master/tests/test_daemon.py~: CountingBus and MultiBus (every method)
- ~master/tests/test_poller.py~: _make_reply
- ~master/tests/test_config.py~: _write_toml
One-liner docstrings (or none) suffice for these.

** Notes
Replaced verbose Args/Returns sections with one-liner docstrings and type
hints in signatures. FakeBus, CountingBus, MultiBus, _write_toml all trimmed.
make_reply (formerly _make_reply) was moved to conftest and trimmed there.
* DONE Trim obvious-command documentation in org files
Several docs explain what competent readers can see from the Makefile:
- ~README.org~ lines 47-63: spells out what ~make build-master~, ~make
  build-slave~, ~make check-master~, ~make check-slave~ do.  The top-level
  ~make~ and ~make check~ lines are fine; the per-target breakdown adds
  little.
- ~panel/README.org~ "Quick start" section: ~make demo-setup~ and ~make
  demo-generate~ have inline comments that duplicate the Makefile.
  Consolidate to just ~make demo-server~ (which is the one that matters)
  and let the reader look at the Makefile for details.
Keep documentation that is non-obvious, like the API reference table in
~panel/README.org~ -- that's valuable.

** Notes
Removed per-target breakdown from README.org (build-master, build-slave,
check-master, check-slave). Removed demo-setup/demo-generate breakdown
from panel/README.org. Kept API reference table.
* DONE Retire docs/panel.org or move to an archive
~docs/panel.org~ was an exploratory design document comparing three
visualization options.  The decision was made (Option B) and is fully
implemented.  The file is historical noise now.  Either delete it or move
it to a ~docs/archive/~ directory so ~docs/~ only contains current specs.

** Notes
Deleted the file. The design rationale is preserved in the archived TODO
items that reference it.
* DONE Batch commits in poll_all

Each ~Storage.insert()~ call commits immediately.  For a poll cycle with
4 slaves, this means 4 separate transactions.  Batching into one commit
per cycle would reduce write overhead:

#+begin_example
# In Poller.poll_all, after the loop:
self._storage.commit()
#+end_example

This requires exposing ~commit()~ on Storage and removing the per-insert
commit.  Not critical at this scale, but it's a 3-line change that makes
the write pattern cleaner.

** Notes
Removed per-insert commit from Storage.insert(), added Storage.commit()
method, and poll_all() now calls commit() once after all inserts.
Updated storage tests to call commit() before fetch().
* DONE Duplicated CREATE TABLE SQL
The ~readings~ table schema appears in three places:
- ~master/src/tmon/storage.py~
- ~panel/generate_data.py~
- ~panel/tests/conftest.py~
Since panel deliberately avoids importing from master, this is somewhat
expected, but the generate_data.py copy could at least reference
docs/storage.org so a reader knows the schema is defined there.  Consider
adding a one-line comment in each copy pointing to the canonical schema in
~docs/storage.org~.

** Notes
- ~master/src/tmon/storage.py~ already referenced docs/storage.org in its
  module docstring, so no change needed there.
- Added ~# Schema: see docs/storage.org~ comment above _CREATE_TABLE in
  ~panel/generate_data.py~ and ~panel/tests/conftest.py~.
- Updated ~panel/generate_data.py~ docstring to reference docs/storage.org
  instead of master/src/tmon/storage.py.
* DONE Add "Bare UART test" milestone to PLAN.org
Insert between "Blink test" and "Full firmware" in the ESP32 firmware
section. This milestone validates UART communication before adding
RS-485 hardware complexity.

Checklist for the milestone:
- Document Pi UART setup in docs/wiring.org (disable BT, enable UART)
- ESP32 UART2 wired directly to Pi UART (TX->RX, RX->TX, GND)
- Firmware: configure UART on GPIO 16/17, toggle DE/RE on GPIO 5
- Echo test: ESP32 echoes received bytes
- Protocol test: ESP32 responds to POLL_REQUEST with dummy data
- Master talks to real ESP32 over /dev/serial0

** Notes
Milestone added to PLAN.org in commit 4848bc5.
* WAITING Missing index on readings table

- State "WAITING"    from "TODO"       [2026-02-04 Wed 11:13] \\
  This isn't urgent.
The ~readings~ table (schema/readings.sql) has no indexes beyond the
primary key.  The panel's ~/api/history~ and ~/api/export~ endpoints
filter by ~(addr, ts)~ range:

#+begin_example
SELECT ... FROM readings WHERE addr = ? AND ts >= ? AND ts <= ?
#+end_example

With a year of data (~3M rows per slave), this scans the full table.
Adding a composite index would help:

#+begin_example
CREATE INDEX idx_readings_addr_ts ON readings(addr, ts);
#+end_example

This is a straightforward change to ~schema/readings.sql~.  Existing
databases can be migrated with a one-time ~CREATE INDEX~ command.
* DONE Fragile schema loading path in storage.py

~storage.py~ loads the schema from ~schema/readings.sql~ using relative
path traversal:

#+begin_example
_SCHEMA_PATH = Path(__file__).resolve().parents[3] / "schema" / "readings.sql"
#+end_example

This works in development but would break if the package is pip-installed
to site-packages (the directory structure differs).

Options:
1. Embed the schema as a string constant in storage.py (simple, robust).
2. Use ~importlib.resources~ to load from a package data directory.

For a home project, option 1 is fine.  The schema is 12 lines and rarely
changes; keeping it inline avoids deployment edge cases.
* DONE Document Pi UART setup in wiring.org
Add a section for the Pi side GPIO UART configuration:
- /boot/firmware/config.txt: enable_uart=1, dtoverlay=disable-bt
- Disable serial console in /boot/firmware/cmdline.txt
- Result: /dev/serial0 available on GPIO 14 (TX) / GPIO 15 (RX)

Also document the wiring progression:

Phase 1 - Bare UART test:
  ESP32 GPIO 17 (TX) -> Pi GPIO 15 (RX)
  ESP32 GPIO 16 (RX) <- Pi GPIO 14 (TX)
  GND <-> GND
  ESP32 GPIO 5 (DE/RE) toggled but not connected

Phase 2 - With MAX485:
  Move wires from Pi GPIO to MAX485 (DI, RO, DE+RE, GND).
  Pi uses USB-RS485 adapter (/dev/ttyUSB0) instead of GPIO UART.

ESP32 wiring is identical in both phases - just the Pi side changes.

** Notes
Implemented in commit 4848bc5 as part of branch claude/031-esp32-s3-uart-docs.
* DONE Update wiring.org for ESP32-S3
The current wiring doc assumes ESP32-WROOM-32. Update pin assignments
for ESP32-S3:
- UART: GPIO 16 (RX), GPIO 17 (TX) - same pins as WROOM-32 but via GPIO matrix
- DE/RE: GPIO 5 - direction control for MAX485
- ADC1: GPIO 1-10 (channels 0-9) on S3, not GPIO 32-35
- Board: esp32-s3-devkitc-1

These pins work for both bare UART test and later MAX485 connection.
Defer until blink test passes and we confirm hardware works.

** Notes
Implemented in commit 4848bc5 as part of branch claude/031-esp32-s3-uart-docs.
* DONE YOLO with wifi!
Crazy idea, how about we add an option so we can test the entire
project over wifi, no cables.  Well, we'd still need to wire the NTC's to each esp32, but the esp32 and pis (or x86 linux) would talk over wifi.  Draft up a plan for the entire thing as a TODO item in TODO.org

Since we currently don't even have the rs485/uart implementation ready (it's just an echo stub), implement that as well as part of this work.  With some way where we can choose whether we're running in rs485/uart mode or wifi (as a parameter, or makefile target or whatever).

Implement it all in a branch.

Use your best judgement, following the style and goals of this project.  Ask few questions.

Use multiple small commits easy to review.  Use the guidelines for simplicity, etc in this project.

Make sure SSID/passwd can be set in toml (or somewhere configurable) for both client/server.  Make sure we can test with make file.  Implement the entire wifi client for the esp32 as it would ultimately work...

Can you do this, or is anything not clear?  Don't ask too many questions, but if anything absolutely needs clarification, ask now before you start.

** Notes
Implemented WiFi as alternative transport to RS-485:

Master side:
- ~wifi_bus.py~: TCP server that accepts slave connections
- Slaves send 1-byte address on connect for identification
- Same binary protocol over TCP instead of serial
- Config: ~transport = "wifi"~ with ~[wifi]~ section for host/port
- ~config-wifi.toml~ sample configuration

Slave side:
- ~handler.c~: Protocol message handler (responds to POLL with REPLY)
- ~sensors.cpp~: NTC thermistor reading with Steinhart-Hart equation
- ~main.cpp~: UART transport with inter-byte timeout for frame assembly
- ~main_wifi.cpp~: WiFi transport with auto-reconnect
- platformio.ini: ~uart~ and ~wifi~ build environments
- WiFi config via build flags: ~-DWIFI_SSID=\"...\"~ etc.

Build/test:
- ~make build-slave~ / ~make build-slave-wifi~
- ~make flash-slave~ / ~make flash-slave-wifi~
- ~make check~ runs all tests including WiFi integration tests

Architecture: TCP client-server model where slaves initiate connection
to master. This avoids NAT/firewall issues and simplifies reconnection.
* DONE Address the issue of wifi credentials in toml file.
Moved sensitive WiFi credentials (ssid/password/master_host) to a separate
file that is gitignored.

** Notes
- ~master/wifi.toml.example~ is a template for credentials (tracked)
- ~master/wifi.toml~ is gitignored (actual credentials)
- ~master/config-wifi.toml~ has WiFi transport settings, no credentials (tracked)
- ~master/config.toml~ is RS-485 only (tracked)
- ~wifi_config.py~ fails loudly with a helpful message if ~wifi.toml~ is missing
- ~make run-master~ for RS-485, ~make run-master-wifi~ for WiFi
* DONE Remove timeout from user config
The receive timeout is an implementation detail users shouldn't need to
configure. Hardcode it internally and simplify the Bus/WifiBus APIs.

** Notes
Removed timeout_ms from config files and Bus/WifiBus constructors.
TIMEOUT_MS=200 is now a constant in config.py.
* DONE Convert WiFi transport from TCP to UDP push model

Replace the current TCP-based WiFi transport with a simpler UDP push model
where slaves wake periodically, send readings, and sleep.

** Background

The current WiFi implementation uses TCP with persistent connections:
- Master runs a TCP server
- Slaves connect as clients and maintain connection
- Master polls, slaves reply
- ~160 lines in wifi_bus.py plus reconnect logic on slave

This works but is more complex than necessary for this use case.

** Proposed design: UDP push with deep sleep

Slaves take control of timing:
1. Slave wakes from deep sleep on timer
2. Connects to WiFi
3. Sends UDP packet with readings to master
4. Goes back to deep sleep

Master just listens:
1. Binds UDP socket on known port
2. Receives readings, stores them
3. Detects offline slaves by absence of readings

*** Frame format

Same protocol frame as today, but slave-initiated:

#+begin_example
[START] [ADDR] [CMD=REPLY] [LEN=8] [temps...] [CRC_LO] [CRC_HI]
#+end_example

No POLL command needed. Slave just sends REPLY frames periodically.

*** No registration needed

The readings frame already contains the slave address (ADDR byte).
When master receives a UDP packet, ~recvfrom()~ provides the source IP.
First reading = implicit registration. No separate hello packet needed.

If a slave gets a new DHCP lease, the next reading updates the mapping
automatically.

*** Configuration

Slave needs:
- WiFi credentials (already in wifi.toml)
- Master IP/port (already in wifi.toml)
- Push interval (new: add to wifi.toml or as build flag)

Master needs:
- Listen port (already in config-wifi.toml)

** Options considered

*** Option 1: TCP poll (current)

Master polls, slaves reply over persistent TCP connections.

Pros:
- Master controls timing
- Readings perfectly synchronized

Cons:
- Complex connection management (~160 lines)
- Reconnect logic on both sides
- Cannot use sleep modes (connection would drop)
- ~75mW continuous power

*** Option 2: UDP poll

Master polls via UDP, slaves reply.

Pros:
- Simpler than TCP (no connection state)
- ~50 lines instead of ~160

Cons:
- Still master-initiated, so slaves must stay awake to listen
- Same power as TCP (~75mW)
- Need slave discovery mechanism

*** Option 3: UDP push with deep sleep (recommended)

Slaves wake on timer, push readings, sleep.

Pros:
- Simplest protocol (no request/response)
- No connection state
- True deep sleep between pushes
- Significant power savings at longer intervals
- Slave controls its own schedule (no timing sync issues)
- ~40-50 lines on master, simpler slave code

Cons:
- Readings not perfectly synchronized (each slave on own timer)
- Master cannot request on-demand reading
- Slave needs interval configured

For temperature monitoring with minute-scale intervals, the cons are
irrelevant. We don't need synchronized readings or on-demand polls.

** Power analysis

Assumptions:
- ESP32-S3 at 3.3V
- Deep sleep: ~0.02mA
- WiFi wake cycle (connect + send): ~150mA for ~2 seconds
- Always-on WiFi idle: ~25mA

*** Per-slave power consumption

| Mode        | Interval |  Avg mA |   Power |
|-------------+----------+---------+---------|
| Always-on   | -        | 25.0 mA |   75 mW |
| Deep sleep  | 30s      | 10.0 mA |   33 mW |
| Deep sleep  | 60s      |  5.0 mA |   17 mW |
| Deep sleep  | 5min     |  1.0 mA |  3.4 mW |

*** Annual energy (3 slaves)

| Mode        | Interval | kWh/year | EUR/year (Girona) |
|-------------+----------+----------+-------------------|
| Always-on   | -        |     1.97 |              0.30 |
| Deep sleep  | 30s      |     0.87 |              0.13 |
| Deep sleep  | 60s      |     0.43 |              0.06 |
| Deep sleep  | 5min     |     0.09 |              0.01 |

Electricity cost: 0.15 EUR/kWh (Girona, Spain average).

At 5-minute intervals: ~22x power reduction, saves 0.29 EUR/year.
Cost savings are negligible, but simpler code is the real win.

** Implementation plan

*** Phase 1: Master UDP listener

- [X] Create ~udp_receiver.py~ with simple recv loop
- [X] Store readings on receipt (no polling logic)
- [X] Detect offline slaves by timestamp threshold
- [X] Add ~transport = "udp"~ config option
- [X] Unit tests with mock UDP

*** Phase 2: Slave UDP push

- [X] Create ~main_udp.cpp~ with wake/send/sleep cycle
- [X] Configure interval via build flag (~-DPUSH_INTERVAL_S=60~)
- [X] Deep sleep between pushes
- [X] Add ~make flash-slave-udp~ target

*** Phase 3: Cleanup

- [X] Remove TCP transport (~wifi_bus.py~, ~main_wifi.cpp~)
- [X] Update docs/wiring.org WiFi section
- [X] Update docs/protocol.org with push model

** Notes

Implemented UDP push as replacement for TCP WiFi transport:

Master side:
- ~udp_receiver.py~: Simple UDP socket receiver
- ~listener.py~: Decodes REPLY frames, stores to DB
- ~daemon.py~: New ~run_listener()~ loop for UDP mode
- Renamed ~poller.py~ to ~poller.py~ for consistency

Slave side:
- ~main_udp.cpp~: Wake, connect WiFi, send REPLY, deep sleep
- ~PUSH_INTERVAL_S~ build flag (default 60s)
- LED: Yellow connecting, green flash on send, off during sleep

Removed TCP WiFi transport entirely:
- ~wifi_bus.py~, ~main_wifi.cpp~, ~config-wifi.toml~
- Associated tests and Makefile targets

Commits:
1. Rename Poller to Poller (poller.py)
2. Add UDPReceiver
3. Add Listener (listener.py)
4. Update config/daemon for UDP
5. Add UDP integration tests
6. Add main_udp.cpp with deep sleep
7. Remove TCP transport, update docs

** Post Mortem

Comparisons of transport implementations for future reference.

*** TCP vs UDP
**** Lines of Code (excluding tests)

| Component        | TCP                      | UDP                       |
|------------------+--------------------------+---------------------------|
| Python bus       | wifi_bus.py: 166         | udp_receiver.py: 79            |
| Python collector | (reuses Poller)          | listener.py: 134  |
| Slave firmware   | main_wifi.cpp: 161       | main_udp.cpp: 169         |
| Daemon changes   | +10 lines                | baseline                  |
| TOTAL            | ~337                     | ~382                      |

UDP has ~45 more lines because it needs a separate collector (TCP reused
Poller). However, LOC alone is misleading.

**** Maintainability

TCP was harder to maintain:
- Background thread for accepting connections (~_accept_loop~)
- Connection state per slave (socket map with locking)
- Reconnection logic, socket lifecycle management
- Slave address-to-socket routing

UDP is easier:
- ~udp_receiver.py~ is 79 lines of stateless socket code
- No threading, no connection state, no address routing
- Each component has a single responsibility

Winner: UDP, despite more total LOC.

**** Readability

TCP:
- ~wifi_bus.py~: Threading and socket map add cognitive load
- ~main_wifi.cpp~: Connection management and frame reassembly add noise

UDP:
- ~udp_receiver.py~: Bind socket, receive datagrams. Trivial.
- ~listener.py~: Clean separation. Frame decode, store, done.
- ~main_udp.cpp~: Linear flow: wake -> connect -> build -> send -> sleep

Winner: UDP. Code reads top-to-bottom with no hidden complexity.

**** Efficiency

Power:
- TCP: Slave stays awake for TCP connection and master polls
- UDP: Wake, send one packet, deep sleep
- Winner: UDP (dramatically better for battery-powered ESP32s)

Network:
- Roughly equivalent for periodic temperature readings

Reliability:
- TCP: Guaranteed delivery, but connection management fragile on home WiFi
- UDP: Fire and forget. Acceptable for periodic non-critical readings.
- TCP slightly better in theory, negligible in practice

Winner: UDP for power efficiency.

**** Conclusion

Keep UDP. The ~45 extra lines are a fair trade for dramatically simpler
code and better power efficiency. TCP had more hidden complexity despite
fewer lines.

*** RS-485 vs UDP

Comparison for choosing between wired (RS-485) and wireless (UDP push)
transports. Context: home network with "relatively good" reliability.

**** Lines of Code (excluding tests)

| Component        | RS-485                        | UDP                           |
|------------------+-------------------------------+-------------------------------|
| Slave firmware   | main.cpp: 127                 | main_udp.cpp: 169             |
|                  | handler.cpp: 69               | (no handler needed)           |
|                  | protocol.cpp: 212 (shared)    | protocol.cpp: 212 (shared)    |
|------------------+-------------------------------+-------------------------------|
| Slave total      | 408                           | 381                           |
|------------------+-------------------------------+-------------------------------|
| Master daemon    | bus.py: 69                    | udp_receiver.py: 79                |
|                  | poller.py: 159        | listener.py: 134      |
|                  | protocol.py: 198 (shared)     | protocol.py: 198 (shared)     |
|                  | daemon.py: 154 (shared)       | daemon.py: 154 (shared)       |
|------------------+-------------------------------+-------------------------------|
| Master total     | 580                           | 565                           |
|------------------+-------------------------------+-------------------------------|
| TOTAL            | 988                           | 946                           |

Nearly identical. The difference is noise.

**** Maintainability

RS-485 wins.

- Fewer moving parts: no WiFi, DHCP, DNS, or network infrastructure
- Simpler debugging: logic analyzer on the bus shows every byte
- Less configuration: just slave address, no credentials or IP
- Immediate failure detection: poll fails instantly vs stale timeout
- Silent failures: UDP fire-and-forget hides problems longer

**** Readability

RS-485 wins slightly.

- ~main.cpp~: Classic embedded pattern (setup/loop, accumulate bytes,
  timeout-based frame detection, respond). Any embedded dev recognizes it.
- ~main_udp.cpp~: "setup does everything, loop is dead code" is less
  intuitive for those unfamiliar with ESP32 deep sleep.
- Python collectors: Both equally readable.

**** Efficiency

Power: UDP wins dramatically (deep sleep between pushes).
Latency: RS-485 wins (sub-second response vs minutes between pushes).

For wall-powered sensors, power efficiency is irrelevant.

**** Reliability on home network

UDP is acceptable. Occasional lost packet at 5-minute intervals is
harmless. ~stale_slaves()~ handles detection.

However, "relatively good" WiFi can degrade: router reboots, DHCP lease
changes, 2.4GHz congestion. RS-485 is a wire and just works.

**** Recommendation

For set-and-forget home monitoring with wired power: RS-485.
- Simpler debugging when something breaks
- No WiFi infrastructure dependency
- Immediate failure detection
- Comparable code complexity

UDP makes sense when:
- Battery-powered sensors (deep sleep matters)
- Running wire is impractical
- Multiple buildings/structures
* DONE Rename Udp to UDP
There are still instances of:
class TestUdpIntegration:
notice Udp awkwardness.  Fix any other places in the code base.

** Notes
Only one instance in code: TestUdpIntegration -> TestUDPIntegration in
test_udp_integration.py.  The WiFiUdp.h include is an Arduino library,
not ours.
* DONE Move ~Reading~ dataclass out of ~rs485_poller.py~
~Reading~ is defined in ~rs485_poller.py:29-40~ but imported by
~udp_listener.py:15~.  A transport-neutral data type shouldn't live in a
transport-specific module.  Move to its own module (e.g. ~reading.py~)
or to ~protocol.py~.

** Notes
Moved to ~reading.py~. Updated imports in ~rs485_poller.py~,
~udp_listener.py~, ~test_rs485_poller.py~, and ~test_udp_listener.py~.
* DONE Extract duplicated ~_fmt()~ temperature formatter
Identical function in ~rs485_poller.py:116-117~ and
~udp_listener.py:87-88~:

#+begin_example
def _fmt(t):
    return f"{t / 10:.1f}" if t is not None else "--.-"
#+end_example

Extract to a shared location (e.g. ~protocol.py~ or wherever ~Reading~
lands).

** Notes
Extracted as ~fmt_temp()~ in ~reading.py~. Both ~rs485_poller.py~ and
~udp_listener.py~ now import it from there.
* DONE Fix ~bus~ parameter name in ~daemon.py:run_listener()~
~daemon.py:70~: ~run_listener(bus, storage)~ -- but receives a
~UDPReceiver~, not a bus.  Should be ~receiver~ to match what it
actually is.

** Notes
Renamed parameter from ~bus~ to ~receiver~. Updated docstring example.
* DONE Rename ~encode_request~ to ~encode_frame~
~protocol.py:75~: function encodes any frame (POLL or REPLY), not just
requests.  Its own docstring says "Build a complete protocol frame".
Used for REPLY encoding in ~serial_simulator.py:75~, ~conftest.py:11~,
~test_rs485_bus.py:51~.

C side: ~tmon_encode_request~ -> ~tmon_encode_frame~ too.

** Notes
Renamed in 13 files across Python and C. All tests pass (97 Python,
51 C via Unity).
* DONE Harmonize wifi/udp naming across build and code
Python: ~udp_receiver.py~, ~udp_listener.py~, ~UDPReceiver~,
~transport = "udp"~, ~config-udp.toml~.

Makefile/PlatformIO: ~flash-slave-wifi~, ~run-master-wifi~,
~build-slave-wifi~, ~env:wifi~.

These diverged when TCP was replaced by UDP but build targets weren't
renamed.  Pick one convention: either rename build targets to ~-udp~ or
accept the split and add a comment explaining why.

** Notes
Renamed all build targets and PlatformIO env from ~wifi~ to ~udp~:
~build-slave-udp~, ~flash-slave-udp~, ~run-master-udp~, ~[env:udp]~.
Updated ~README.org~ references.
* DONE Inconsistent UDP class naming
~UDPReceiver~ (prefixed) vs ~Listener~ (not prefixed).  Both live in
~udp_*.py~ modules, but only one carries the ~UDP~ prefix in the class
name.  Either both should be prefixed (~UDPReceiver~, ~UDPListener~) or
neither should (~Receiver~, ~Listener~).

** Notes
Renamed ~Listener~ to ~UDPListener~. Updated ~daemon.py~,
~test_udp_listener.py~, and ~test_udp_integration.py~.
* DONE Implement UDP simulator if needed
We have a simulator for the RS485 slaves, but we have two modes of operation, RS485 and UDP.
We should factor out the 485 bits, such that we have a file with the 485 bits, another one with UDP simulator bits, and a serial_simulator.py for the overall general simulator interface-- probably dispatching to either one depending on how its being run.

I'm not sure whether integration tests already cover UDP, and if so, this work is probably not needed.  Heck, if we already test UDP testing as a unit test, then perhaps we could do the same for the simulator, and avoid the simulator altogether.

Explore whether we need the simulator (any of them), or if we need to refactor things out so that we have an rs485 sim and a udp sim.  Whatever feels more natural and clean going forward.

** Notes
No UDP simulator needed. UDP tests already cover the full push cycle
through direct socket injection (12 tests across test_udp_listener.py,
test_udp_receiver.py, and the UDP integration tests). This is simpler
and more reliable than a standalone simulator process.

The RS-485 simulator stays as-is because serial I/O requires socat PTY
infrastructure; UDP has no such constraint.

The one testing gap found was that test_daemon.py tested run_poller
(RS-485 daemon loop) but had no test for run_listener (UDP daemon loop).
Added CountingReceiver test double and TestRunListener with two tests.
* DONE LED stub diverges from real hardware behavior
~led.cpp:led_blink()~ unconditionally sets ~state_before_tx = LED_OFF~,
meaning any successful TX clears error state.  ~led_stub.cpp:led_blink()~
conditionally preserves ~state_before_tx~ if already in TX state:

#+begin_example
// led.cpp (real hardware)
void led_blink (void) {
  state_before_tx = LED_OFF;  // always clears error
  ...
}

// led_stub.cpp (test double)
void led_blink (void) {
  if (current_state != LED_TX)
    state_before_tx = current_state;  // preserves error if in TX
  ...
}
#+end_example

The test ~test_blink_tx_returns_to_error~ passes against the stub but
would fail on real hardware.  Pick one behavior and make both match.
* DONE Stale config.toml comment references config-wifi.toml
~master/config.toml~ line 6 says:

#+begin_example
# For WiFi transport, use config-wifi.toml instead.
#+end_example

The file was renamed to ~config-udp.toml~ during the TCP-to-UDP migration.
One-line fix.

** Notes
Updated comment in ~master/config.toml~ from ~config-wifi.toml~ to ~config-udp.toml~.
* WAITING UDP listener commits per reading, RS-485 poller batches per cycle
- State "WAITING"    from "TODO"       [2026-02-08 Sun 22:29] \\
  I'm not sure we should fix this.  UDP connections can come sporadically, and waiting until N numbers would mean waiting an indeterminate amount of time.
~serial_poller.py:poll_all()~ calls ~storage.commit()~ once after all
inserts (batched).  ~udp_listener.py:_process_frame()~ calls
~storage.commit()~ after every single reading.

For consistency and reduced I/O, the listener should batch commits too.
One approach: have ~run_listener()~ in daemon.py call ~storage.commit()~
periodically (e.g. every N readings or every M seconds) rather than
per-frame.
* DONE Remove unused TMON_MAX_PAYLOAD constant
~slave/include/protocol.h~ defines ~TMON_MAX_PAYLOAD = 255~ but nothing
references it.  Either use it for validation in ~tmon_decode_frame()~ or
remove the dead definition.
* DONE Add context managers to Storage and UDPReceiver
~Storage~, ~SerialBus~, and ~UDPReceiver~ all require explicit
~close()~ calls.  Adding ~__enter__~ / ~__exit__~ methods would allow
~with~ usage and prevent resource leaks.  Low priority since the daemon
handles cleanup via ~try/finally~ already.
* DONE Validate SLAVE_ADDR range at build time
~slave_addr.py~ injects ~SLAVE_ADDR~ from the environment variable with
default "1" but no range check.  A typo like ~SLAVE_ADDR=0~ or
~SLAVE_ADDR=300~ compiles fine but produces frames the master rejects.
Add a range check (1-247) in ~slave_addr.py~.
** Notes
Added integer parsing and range validation (1-247) in slave_addr.py.
Invalid or out-of-range values cause env.Exit(1) with a clear message.
* DONE Fix negative temperature display bug in log.h
~slave/include/log.h:30-33~: for temperatures between -0.9 C and 0.0 C
(raw int16 values -9 to -1), the sign is lost.  C integer division
truncates toward zero: ~-5 / 10 = 0~, so ~-0.5 C~ displays as ~0.5~
instead of ~-0.5~.  Need to check for negative values where the integer
part is zero and prepend a minus sign.
** Notes
Added a guard in log_temps: when the raw value is negative but integer
division yields zero (values -9 to -1, i.e. -0.9 C to -0.1 C), prepend
a minus sign before printing.  No test added because log_temps depends
on Arduino Serial and cannot run in the native test environment without
mocking infrastructure.
* DONE Fix sensors.h header comment (Steinhart-Hart vs B parameter)
~slave/include/sensors.h:6~ says "Uses Steinhart-Hart equation" but the
code uses the B parameter equation (a simplified single-coefficient form).
~sensors.cpp~ correctly describes it as "B parameter equation" internally.
The header comment should match what the code actually does.
** Notes
One-line fix: changed "Steinhart-Hart equation" to "B parameter equation"
in sensors.h to match the actual implementation in sensors.cpp.
* DONE Pass shutdown event into daemon functions instead of module global
~daemon.py~ uses a module-level ~threading.Event~ (~_shutdown~) that
signal handlers set.  Tests must reach into ~daemon_mod._shutdown~
directly.  Pass the event as a parameter to ~run_poller~ and
~run_listener~ so tests can inject their own event cleanly and parallel
test execution cannot interfere.
** Notes
Added ~shutdown~ parameter to ~run_poller()~ and ~run_listener()~.
~main()~ passes the module-level ~_shutdown~; ~_on_signal~ still sets it.
Test doubles now accept a local ~threading.Event~ instead of reaching
into ~daemon_mod._shutdown~. ~test_on_signal_sets_shutdown~ unchanged
(tests the signal handler which uses the module-level event).
* DONE Rename leftover "steinhart" variable in sensors.cpp
~sensors.cpp:62~: local variable ~steinhart~ was named when the code
used the Steinhart-Hart equation.  Now it uses the B parameter equation.
Rename to ~inv_temp~ or ~temp_inv~ to match the actual semantics.
** Notes
Renamed ~steinhart~ to ~inv_temp~ on lines 62, 74, 75, 76 of sensors.cpp.
* TODO NVS-based per-device configuration for ESP32 firmware

Currently, ~SLAVE_ADDR~ and WiFi credentials are compile-time constants
baked into the firmware binary via PlatformIO build flags
(~slave_addr.py~, ~wifi_config.py~).  This means we ship one firmware
binary per address/mode combination (8 binaries total).

The ESP32 NVS (non-volatile storage) system can store per-device
configuration separately from the firmware image.  This would let us
build one firmware per transport mode (serial + udp = 2 binaries) and
set the slave address and WiFi credentials at flash time.

** Approach

- Use the Arduino ~Preferences~ library to read ~slave_addr~, ~ssid~,
  ~password~, ~master_host~ from NVS at boot.
- Generate NVS partition images with ~nvs_partition_gen.py~ (ships with
  ESP-IDF) containing per-device values.
- Flash the NVS partition alongside the firmware:
  ~esptool.py write_flash 0x9000 nvs.bin~
- Update ~tmon-flash~ to accept ~--ssid~, ~--password~, ~--host~ and
  generate the NVS image on the fly.

** Benefits

- One firmware binary per transport mode instead of one per address.
- Config changes (new WiFi password, different address) without
  rebuilding firmware.
- Credentials never baked into the binary.

** Scope

- Firmware: replace build-flag reads with Preferences reads + fallback.
- ~tmon-flash~: add NVS partition generation and flashing.
- Build: simplify ~make firmware~ (2 binaries instead of 8).

* DONE Rewrite master in C and compare with Python implementation

Exploratory rewrite of the Python master daemon in C (GNU style) to
evaluate whether a C implementation is worth maintaining.  The C code
lives on branch ~claude/053-c-rewrite~ and is preserved under tag
~c-rewrite~.

** Comparison

| Metric         | Python       | C                        |
|----------------+--------------+--------------------------|
| Source LOC     | ~1,094       | ~2,172 (src + headers)   |
| Test LOC       | ~1,750       | ~1,257                   |
| Test count     | 103          | 56                       |
| Dependencies   | pyserial + stdlib | sqlite3 + POSIX     |
| Feature parity | 100%         | ~100% (no integration tests) |

The C version is 2x the source code for identical functionality, with
roughly half the test coverage.

*** Where C wins

- No runtime dependency -- no Python interpreter, no virtualenv, no
  pyserial.  Just a static binary + libsqlite3.
- Lower resource use -- relevant if running on a constrained device
  (this project runs on a Linux box, so moot).
- Deployment simplicity -- copy one binary vs managing a Python
  environment.

*** Where Python wins

- Half the code -- 1,094 vs 2,172 lines.  Less code = fewer bugs,
  faster changes.
- Far better test coverage -- 103 tests vs 56.  Python has integration
  tests and daemon-loop tests that C lacks entirely.
- Faster to modify -- adding a new feature takes far fewer lines and
  less ceremony.
- Safer by default -- no manual memory management, no buffer overflows.
- Config parsing -- stdlib ~tomllib~ vs 324-line hand-rolled TOML
  subset parser.
- Testing is trivial -- duck typing means any object with matching
  methods works as a test double.  C needs explicit function pointer
  plumbing.

** Notes

Decision: keep the Python version.

This is a home-use monitoring daemon running on a Linux box.  The C
rewrite is well-written (clean GNU style, good module boundaries,
proper opaque handles) but does not buy anything meaningful for this
use case:

1. Maintenance cost is higher in C.  Every change requires touching
   headers + source + rebuilding.
2. The test gap is real.  Closing it in C would add hundreds more
   lines.
3. The deployment argument is weak -- the target machine already has
   Python.
4. Risk surface -- C code handles raw buffers, POSIX file descriptors,
   and manual resource cleanup.  Every future change carries risk that
   Python prevents structurally.

The C version would make sense if targeting an embedded Linux board
with no Python, or if microsecond-level timing were needed.  For a
daemon that wakes up every 30 seconds to poll temperature sensors,
Python is the right tool.

Archived C implementation: tag ~c-rewrite~, branch ~claude/053-c-rewrite~.
* TODO LED overhaul
UDP client should stay connected all the time, avoid deep sleep.  The
power savings isn't worth it.

Serial client never turns on lights at all.  Serial should be working,
and if it isn't, it'll be clear from the logs.

UDP client only blinks red when no wifi, otherwise nothing.  This simplifies the entire LED system.  Red for no wifi, otherwise no lights.  UDP client will try to connect to wifi, if can't, blinks lights for 10 seconds, then retries.  Continues on this loop until connects to wifi.

Update LED docs in *.org if necessary.

Do this TODO in various logical commits.
* TODO Boot button triggers address query

Change both firmware versions such that pressing the boot button makes the device blink yellow N times, where N is the ADDR.  This way the installer has a way of knowing what address a given node is.
